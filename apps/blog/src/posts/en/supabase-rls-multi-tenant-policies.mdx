---
title: "Supabase RLS for Multi-tenant SaaS: The Three Policy Patterns That Actually Work"
description: "One RLS misconfiguration and Tenant A sees Tenant B's data. Here are the three policy patterns I use to prevent that."
date: "2026-02-20"
tags: ["supabase", "typescript", "development", "tips"]
slug: "supabase-rls-multi-tenant-policies"
category: "technical"
author: "Jaeil Lee"
featured: false
seo:
  keywords: ["supabase rls multi tenant", "row level security patterns", "saas data isolation", "supabase workspace rls", "multi tenant postgres"]
---

# Supabase RLS for Multi-tenant SaaS: The Three Policy Patterns That Actually Work

If you run a multi-tenant SaaS, you are one bad query away from a very expensive week.

Not a dramatic, movie-style hack. A normal bug. Someone ships a list API, forgets one `where workspace_id = ...`, and your customer sees another company's rows. That is the type of failure that looks small in code review and huge in trust damage.

I wrote about AI tool-calling + database safety in [Stop Letting Your AI Chatbot Write Raw SQL](/en/secure-ai-chatbot-supabase-rls). The short version was: prompts are suggestions, RLS is enforcement. This post goes one layer deeper: not just "use RLS," but which policy shape to use when your product evolves from single-user apps to workspace/team SaaS.

I also recommend reading [Supabase Auth From Scratch](/en/supabase-auth-from-scratch) first if your auth/session plumbing is still in progress. Your policies depend on having reliable user identity in JWTs.

Below are the three RLS policy patterns I keep reusing in production.

## 1. The Fear: Data Bleeding Between Tenants

Most data leaks in SaaS apps are not caused by malicious attackers. They are caused by normal feature velocity.

The typical path looks like this:

1. You start with one-user scope and move fast.
2. You add teams/workspaces later.
3. Some endpoints are migrated cleanly, others are "good enough for now."
4. You rely on app-level filtering in ten places.
5. One filter gets missed.

At that point, you do not have a security architecture. You have a memory challenge for engineers.

RLS flips that model. The database enforces tenant boundaries for every query path: web app, cron, background jobs, AI tools, ad-hoc scripts, anything using non-service credentials.

The mental model I use:

- Application logic decides *what* to ask.
- RLS decides *whether rows are visible at all*.

That split is why RLS scales with team size. Your app code can still be imperfect and your isolation can still be correct.

## 2. Pattern 1: `auth.uid()` Direct Column Check

This is the simplest and safest starting point when rows are owned by a single user.

Use this pattern when:

- each row has `user_id`
- ownership is direct (no team membership lookup)
- your product is personal scope or early-stage single-owner entities

### Schema

```sql
create table notes (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id),
  title text not null,
  body text not null,
  created_at timestamptz not null default now()
);

alter table notes enable row level security;
```

### Policies

```sql
create policy "notes_select_own"
on notes
for select
to authenticated
using ((select auth.uid()) = user_id);

create policy "notes_insert_own"
on notes
for insert
to authenticated
with check ((select auth.uid()) = user_id);

create policy "notes_update_own"
on notes
for update
to authenticated
using ((select auth.uid()) = user_id)
with check ((select auth.uid()) = user_id);

create policy "notes_delete_own"
on notes
for delete
to authenticated
using ((select auth.uid()) = user_id);
```

### Why this works well

- It is readable in 10 seconds.
- It is hard to misinterpret.
- It maps directly to app behavior.

### Performance notes

- Add an index on `user_id`.
- Keep `to authenticated` explicit so Postgres can skip policy evaluation for `anon` paths.
- Use `(select auth.uid())` in policies, not bare `auth.uid()`, so the planner can cache init plan results per statement.

```sql
create index notes_user_id_idx on notes(user_id);
```

If your product will eventually have teams, this pattern is still valuable. It often remains correct for user-private resources (personal drafts, API tokens, preferences) even after workspaces are introduced.

## 3. Pattern 2: Workspace ID via Junction Table

When one row belongs to a workspace and many users can access it, direct `user_id` checks are not enough. You need membership-based access.

Use this pattern when:

- rows contain `workspace_id`
- users gain access via `workspace_members`
- roles (owner/admin/member/viewer) control write privileges

### Schema

```sql
create table workspaces (
  id uuid primary key default gen_random_uuid(),
  name text not null
);

create table workspace_members (
  workspace_id uuid not null references workspaces(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  role text not null check (role in ('owner', 'admin', 'member', 'viewer')),
  primary key (workspace_id, user_id)
);

create table projects (
  id uuid primary key default gen_random_uuid(),
  workspace_id uuid not null references workspaces(id) on delete cascade,
  name text not null,
  created_at timestamptz not null default now()
);

alter table workspace_members enable row level security;
alter table projects enable row level security;
```

### Helper function for readability

Complex policy SQL gets messy fast. A security-definer helper function keeps policies clean and easier to audit.

```sql
create or replace function public.is_workspace_member(target_workspace_id uuid)
returns boolean
language sql
security definer
set search_path = public
as $$
  select exists (
    select 1
    from public.workspace_members wm
    where wm.workspace_id = target_workspace_id
      and wm.user_id = (select auth.uid())
  );
$$;
```

### Policies

```sql
create policy "projects_select_workspace_members"
on projects
for select
to authenticated
using ((select public.is_workspace_member(workspace_id)));

create policy "projects_insert_workspace_members"
on projects
for insert
to authenticated
with check ((select public.is_workspace_member(workspace_id)));
```

For updates/deletes, you usually want role-aware checks.

```sql
create or replace function public.workspace_role(target_workspace_id uuid)
returns text
language sql
security definer
set search_path = public
as $$
  select wm.role
  from public.workspace_members wm
  where wm.workspace_id = target_workspace_id
    and wm.user_id = (select auth.uid())
  limit 1;
$$;

create policy "projects_update_admin_or_owner"
on projects
for update
to authenticated
using ((select public.workspace_role(workspace_id)) in ('owner', 'admin'))
with check ((select public.workspace_role(workspace_id)) in ('owner', 'admin'));
```

### Why this pattern matters

This is the real multi-tenant default. If your product has teams, this is likely where you live.

It does introduce JOIN-like checks through helper functions, so you need indexes:

```sql
create index workspace_members_user_id_idx on workspace_members(user_id);
create index workspace_members_workspace_id_idx on workspace_members(workspace_id);
create index projects_workspace_id_idx on projects(workspace_id);
```

Without these, policies can become the invisible reason your app feels slower at scale.

## 4. Pattern 3: JWT Custom Claims for Workspace Context

Pattern 2 is robust, but sometimes you want fewer lookups for hot read paths. That's where custom claims can help.

Use this pattern when:

- user operates within one "active workspace" at a time
- high-volume reads make membership checks a bottleneck
- you can reliably refresh JWT claims when workspace context changes

The core idea: include tenant context in JWT claims, then reference it via `auth.jwt()` in policies.

### Example claim shape

```json
{
  "sub": "user-uuid",
  "role": "authenticated",
  "app_metadata": {
    "active_workspace_id": "workspace-uuid",
    "workspace_roles": {
      "workspace-uuid": "admin"
    }
  }
}
```

### Policy using claim

```sql
create policy "projects_select_active_workspace"
on projects
for select
to authenticated
using (
  workspace_id = ((select auth.jwt() -> 'app_metadata' ->> 'active_workspace_id')::uuid)
);
```

You can pair this with role checks:

```sql
create policy "projects_update_active_workspace_admin"
on projects
for update
to authenticated
using (
  (select auth.jwt() -> 'app_metadata' -> 'workspace_roles' ->> workspace_id::text) in ('owner', 'admin')
)
with check (
  (select auth.jwt() -> 'app_metadata' -> 'workspace_roles' ->> workspace_id::text) in ('owner', 'admin')
);
```

### Trade-offs (important)

Custom claims are fast, but they are not automatically real-time. JWTs can become stale.

You need a refresh strategy when:

- member is removed from workspace
- role changes
- user switches active workspace

If claim refresh is sloppy, authorization bugs become subtle.

My practical rule:

- Prefer Pattern 2 as the default for correctness.
- Add Pattern 3 only for specific hot paths with clear refresh mechanics.

Don't optimize yourself into an authorization incident.

## 5. Testing Your RLS Policies Before Shipping

If you only "eyeball" policies, you will ship mistakes. Test them as behavior.

I use three layers:

1. **Positive tests:** allowed user can read/write expected rows.
2. **Negative tests:** cross-tenant attempts return zero rows or RLS errors.
3. **Regression tests:** role changes immediately affect access after token refresh.

### SQL-style isolation checks

In local/dev, you can simulate JWT claims:

```sql
-- Simulate Tenant A user
set request.jwt.claims = '{
  "sub": "11111111-1111-1111-1111-111111111111",
  "role": "authenticated",
  "app_metadata": { "active_workspace_id": "aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa" }
}';

select count(*) from projects where workspace_id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa';
-- expect > 0

select count(*) from projects where workspace_id = 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb';
-- expect 0

reset request.jwt.claims;
```

For membership-table patterns, I also test demotion/removal:

```sql
-- Remove user from workspace
delete from workspace_members
where workspace_id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'
  and user_id = '11111111-1111-1111-1111-111111111111';

-- Re-run select as same user: should now return 0 rows
```

### App-level test example (TypeScript)

```typescript
import { createClient } from "@supabase/supabase-js";

const clientA = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_ANON_KEY!, {
  global: { headers: { Authorization: `Bearer ${process.env.USER_A_JWT!}` } },
});

const clientB = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_ANON_KEY!, {
  global: { headers: { Authorization: `Bearer ${process.env.USER_B_JWT!}` } },
});

const [{ data: aProjects }, { data: bProjects }] = await Promise.all([
  clientA.from("projects").select("id, workspace_id"),
  clientB.from("projects").select("id, workspace_id"),
]);

// Assert no overlap across tenant scopes in your test framework
```

If you have CI for database migrations, put policy tests there. RLS is not a one-time setup; it is a living contract that can regress.

## 6. When to Use Which Pattern (Decision Matrix)

Use this quick matrix when deciding policy shape:

| Situation | Recommended Pattern | Why |
|---|---|---|
| Personal resources tied to one user | Pattern 1 (`auth.uid()` direct) | Minimal complexity, high clarity |
| Team/workspace data with shared access | Pattern 2 (junction table) | Correct membership semantics |
| High-read hot path with stable active workspace context | Pattern 3 (JWT claims) | Fewer lookups, better read latency |
| Unsure between 2 and 3 | Start with Pattern 2 | Optimize later with evidence |

And one anti-pattern to avoid:

- **Do not rely on app-level `where workspace_id = ...` as your primary isolation boundary.** Keep that for UX filtering, not security.

### A pragmatic rollout sequence

If you're migrating an existing SaaS:

1. Add Pattern 1 for user-private tables immediately.
2. Introduce workspace/member schema.
3. Move shared tables to Pattern 2.
4. Add targeted Pattern 3 only where query profiling proves it helps.

That sequence keeps risk low while still leaving room for performance tuning.

## The Takeaway

Multi-tenant RLS is not one policy. It is a set of patterns that match your data shape.

- Pattern 1 gives you clean ownership checks.
- Pattern 2 gives you real workspace authorization.
- Pattern 3 gives you selective performance wins when you can handle claim freshness.

If your current safety depends on engineers remembering every filter, you are operating on hope. Move the boundary into Postgres and let RLS enforce it every time.

If you want the bigger architecture context, read [Stop Letting Your AI Chatbot Write Raw SQL](/en/secure-ai-chatbot-supabase-rls) and [Supabase Auth From Scratch](/en/supabase-auth-from-scratch). Together, those two plus this policy guide form the baseline stack I use for AI-native, multi-tenant SaaS backends.

---

*Need help hardening tenant isolation in your Supabase stack before launch? I specialize in turning fast-moving MVPs into production-safe systems. [Let's talk](mailto:jay@orangec.at).*
