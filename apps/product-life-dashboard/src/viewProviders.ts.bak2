import * as vscode from 'vscode';
import * as path from 'path';
import { VaultParser } from './vaultParser';

type ViewType = 'quickAdd' | 'wip' | 'checklist' | 'tagManager' | 'settings';

export class BaseViewProvider implements vscode.WebviewViewProvider {
  protected static instances: BaseViewProvider[] = [];
  protected _view?: vscode.WebviewView;
  protected vaultParser: VaultParser;
  private viewType: ViewType;

  constructor(
    private readonly _extensionUri: vscode.Uri,
    viewType: ViewType
  ) {
    this.vaultParser = new VaultParser();
    this.viewType = viewType;
    BaseViewProvider.instances.push(this);
  }

  protected static refreshAll() {
    console.log('ğŸ”„ ëª¨ë“  view refresh');
    BaseViewProvider.instances.forEach(instance => {
      instance.refresh();
    });
  }

  public resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    _token: vscode.CancellationToken
  ) {
    console.log(`ğŸ¨ ${this.viewType} View ì´ˆê¸°í™”`);
    this._view = webviewView;

    webviewView.webview.options = {
      enableScripts: true,
      localResourceRoots: [this._extensionUri]
    };

    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

    // ë©”ì‹œì§€ ìˆ˜ì‹  ë¦¬ìŠ¤ë„ˆ
    webviewView.webview.onDidReceiveMessage(
      async (message) => {
        await this.handleMessage(message);
      }
    );
  }

  protected async handleMessage(message: any) {
    console.log(`ğŸ“¨ ${this.viewType} ë©”ì‹œì§€:`, message);

    switch (message.type) {
      case 'webviewReady':
        console.log('âœ… Webview ì¤€ë¹„ ì™„ë£Œ');
        this._update();
        break;
      case 'refresh':
        console.log('ğŸ”„ ìƒˆë¡œê³ ì¹¨ ìš”ì²­');
        this._update();
        break;
      case 'addTodo':
        await this._handleAddTodo(message.text);
        break;
      case 'addChecklist':
        await this._handleAddChecklist(message.text);
        break;
      case 'toggleChecklist':
        await this._handleToggleChecklist(message.index);
        break;
      case 'updateChecklistPriority':
        await this._handleUpdateChecklistPriority(message.index, message.priority);
        break;
      case 'updateTag':
        await this._handleUpdateTag(message.index, message.tag);
        break;
      case 'updateProgress':
        await this._handleUpdateProgress(message.index, message.progress);
        break;
      case 'completeWip':
        await this._handleCompleteWip(message.index);
        break;
      case 'deleteWip':
        await this._handleDeleteWip(message.index);
        break;
      case 'changeLanguage':
        await this._handleChangeLanguage(message.language);
        break;
    }
  }

  public refresh() {
    this._update();
  }

  private async _handleAddTodo(text: string) {
    try {
      console.log(`ğŸ“ TODO ì¶”ê°€: ${text}`);

      const vaultPath = this.vaultParser.getVaultPath();
      if (!vaultPath) {
        vscode.window.showErrorMessage('vault ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
      }

      const wipFilePath = path.join(vaultPath, 'projects', 'current-wip.md');
      const fs = await import('fs');
      const content = fs.readFileSync(wipFilePath, 'utf-8');
      const lines = content.split('\n');
      const wipSectionIndex = lines.findIndex(line => line.startsWith('# ì§„í–‰ì¤‘ì¸ ì‘ì—…'));

      if (wipSectionIndex === -1) {
        vscode.window.showErrorMessage('WIP ì„¹ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
      }

      let lastNumber = 0;
      for (let i = wipSectionIndex + 1; i < lines.length; i++) {
        const match = lines[i].match(/^(\d+)\./);
        if (match) {
          lastNumber = Math.max(lastNumber, parseInt(match[1]));
        } else if (lines[i].startsWith('#')) {
          break;
        }
      }

      const newNumber = lastNumber + 1;
      const newLine = `${newNumber}. ${text} - 0% ì‹œì‘`;

      let insertIndex = wipSectionIndex + 2;
      while (insertIndex < lines.length && lines[insertIndex].match(/^\d+\./)) {
        insertIndex++;
      }

      lines.splice(insertIndex, 0, newLine);
      fs.writeFileSync(wipFilePath, lines.join('\n'), 'utf-8');

      vscode.window.showInformationMessage(`ì¶”ê°€ë¨: ${text}`);
      setTimeout(() => BaseViewProvider.refreshAll(), 100);
    } catch (error) {
      console.error('âŒ TODO ì¶”ê°€ ì‹¤íŒ¨:', error);
      vscode.window.showErrorMessage(`TODO ì¶”ê°€ ì‹¤íŒ¨: ${error}`);
    }
  }

  private async _handleAddChecklist(text: string) {
    try {
      console.log(`âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸ ì¶”ê°€: ${text}`);

      const vaultPath = this.vaultParser.getVaultPath();
      if (!vaultPath) {
        vscode.window.showErrorMessage('vault ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
      }

      const weeklyPath = this.vaultParser.getWeeklyFilePath();
      const fs = await import('fs');

      if (!fs.existsSync(weeklyPath)) {
        vscode.window.showErrorMessage('ì£¼ê°„ ì²´í¬ë¦¬ìŠ¤íŠ¸ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
      }

      const content = fs.readFileSync(weeklyPath, 'utf-8');
      const lines = content.split('\n');

      // ë§ˆì§€ë§‰ ì²´í¬ë¦¬ìŠ¤íŠ¸ í•­ëª© ì°¾ê¸°
      let lastChecklistIndex = -1;
      for (let i = lines.length - 1; i >= 0; i--) {
        if (lines[i].match(/^- \[([ x])\]/)) {
          lastChecklistIndex = i;
          break;
        }
      }

      const newLine = `- [ ] ${text}`;

      if (lastChecklistIndex === -1) {
        // ì²´í¬ë¦¬ìŠ¤íŠ¸ê°€ ì—†ìœ¼ë©´ íŒŒì¼ ëì— ì¶”ê°€
        lines.push(newLine);
      } else {
        // ë§ˆì§€ë§‰ ì²´í¬ë¦¬ìŠ¤íŠ¸ ë‹¤ìŒì— ì¶”ê°€
        lines.splice(lastChecklistIndex + 1, 0, newLine);
      }

      fs.writeFileSync(weeklyPath, lines.join('\n'), 'utf-8');
      vscode.window.showInformationMessage(`ì²´í¬ë¦¬ìŠ¤íŠ¸ ì¶”ê°€: ${text}`);

      setTimeout(() => BaseViewProvider.refreshAll(), 100);
    } catch (error) {
      console.error('âŒ ì²´í¬ë¦¬ìŠ¤íŠ¸ ì¶”ê°€ ì‹¤íŒ¨:', error);
      vscode.window.showErrorMessage(`ì²´í¬ë¦¬ìŠ¤íŠ¸ ì¶”ê°€ ì‹¤íŒ¨: ${error}`);
    }
  }

  private async _handleToggleChecklist(index: number) {
    try {
      const vaultPath = this.vaultParser.getVaultPath();
      if (!vaultPath) {
        vscode.window.showErrorMessage('vault ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
      }

      const weeklyPath = this.vaultParser.getWeeklyFilePath();
      const fs = await import('fs');
      const content = fs.readFileSync(weeklyPath, 'utf-8');
      const lines = content.split('\n');

      const checklistRegex = /^- \[([ x])\]\s+(.+)/;
      let checklistCount = 0;
      let targetLineIndex = -1;
      let completedItem = '';

      // ì™„ë£Œë˜ì§€ ì•Šì€ í•­ëª©ë§Œ ì¹´ìš´íŠ¸ (ì™„ë£Œëœ ì„¹ì…˜ ì´ì „ í•­ëª©ë§Œ)
      for (let i = 0; i < lines.length; i++) {
        // ì™„ë£Œëœ ì„¹ì…˜ ë°œê²¬í•˜ë©´ ì¤‘ë‹¨
        if (lines[i].startsWith('# ì™„ë£Œëœ ì²´í¬ë¦¬ìŠ¤íŠ¸')) {
          break;
        }
        
        const match = lines[i].match(checklistRegex);
        if (match && match[1] === ' ') {
          if (checklistCount === index) {
            targetLineIndex = i;
            completedItem = lines[i].replace('[ ]', '[x]');
            break;
          }
          checklistCount++;
        }
      }

      if (targetLineIndex === -1) {
        vscode.window.showErrorMessage('ì²´í¬ë¦¬ìŠ¤íŠ¸ í•­ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
      }

      // í•­ëª© ì œê±°
      lines.splice(targetLineIndex, 1);

      // ì™„ë£Œëœ ì„¹ì…˜ ì°¾ê¸° ë˜ëŠ” ìƒì„±
      let completedSectionIndex = lines.findIndex(line => line.startsWith('# ì™„ë£Œëœ ì²´í¬ë¦¬ìŠ¤íŠ¸'));


      if (completedSectionIndex === -1) {
        // ì™„ë£Œëœ ì„¹ì…˜ì´ ì—†ìœ¼ë©´ ìƒì„±
        lines.push('', '# ì™„ë£Œëœ ì²´í¬ë¦¬ìŠ¤íŠ¸', completedItem);
      } else {
        // ì™„ë£Œëœ ì„¹ì…˜ ë°”ë¡œ ë‹¤ìŒì— ì¶”ê°€
        lines.splice(completedSectionIndex + 1, 0, completedItem);
      }

      fs.writeFileSync(weeklyPath, lines.join('\n'), 'utf-8');
      vscode.window.showInformationMessage('âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸ ì™„ë£Œ!');
      
      setTimeout(() => BaseViewProvider.refreshAll(), 100);
    } catch (error) {
      console.error('âŒ ì²´í¬ë¦¬ìŠ¤íŠ¸ ì™„ë£Œ ì‹¤íŒ¨:', error);
      vscode.window.showErrorMessage(`ì²´í¬ë¦¬ìŠ¤íŠ¸ ì™„ë£Œ ì‹¤íŒ¨: ${error}`);
    }
  }

  private async _handleUpdateTag(index: number, newTag: string) {
    try {
      const vaultPath = this.vaultParser.getVaultPath();
      if (!vaultPath) {
        vscode.window.showErrorMessage('vault ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
      }

      const wipFilePath = path.join(vaultPath, 'projects', 'current-wip.md');
      const fs = await import('fs');
      const content = fs.readFileSync(wipFilePath, 'utf-8');
      const lines = content.split('\n');

      const regexWithTag = /^\d+\.\s+\[(.+?)\]\s+(.+?)\s+-\s+(\d+)%/;
      const regexWithoutTag = /^\d+\.\s+([^\[].+?)\s+-\s+(\d+)%/;
      let wipCount = 0;
      let targetLineIndex = -1;
      let hasTag = false;

      for (let i = 0; i < lines.length; i++) {
        const matchWithTag = lines[i].match(regexWithTag);
        const matchWithoutTag = lines[i].match(regexWithoutTag);

        if (matchWithTag || matchWithoutTag) {
          if (wipCount === index) {
            targetLineIndex = i;
            hasTag = !!matchWithTag;
            break;
          }
          wipCount++;
        }
      }

      if (targetLineIndex === -1) {
        vscode.window.showErrorMessage('WIP í•­ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
      }

      const line = lines[targetLineIndex];
      if (hasTag) {
        lines[targetLineIndex] = line.replace(/\[(.+?)\]/, `[${newTag}]`);
      } else {
        lines[targetLineIndex] = line.replace(/^(\d+\.\s+)/, `$1[${newTag}] `);
      }

      fs.writeFileSync(wipFilePath, lines.join('\n'), 'utf-8');
      vscode.window.showInformationMessage(`íƒœê·¸ ì—…ë°ì´íŠ¸: ${newTag}`);

      setTimeout(() => BaseViewProvider.refreshAll(), 100);
    } catch (error) {
      console.error('âŒ íƒœê·¸ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', error);
      vscode.window.showErrorMessage(`íƒœê·¸ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ${error}`);
    }
  }

  private async _handleChangeLanguage(language: 'ko' | 'en') {
    try {
      console.log(`ğŸŒ ì–¸ì–´ ë³€ê²½: ${language}`);
      const config = vscode.workspace.getConfiguration('productLife');
      await config.update('language', language, vscode.ConfigurationTarget.Global);

      vscode.window.showInformationMessage(`ì–¸ì–´ê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤: ${language === 'ko' ? 'í•œêµ­ì–´' : 'English'}`);

      // ëª¨ë“  view refresh
      setTimeout(() => BaseViewProvider.refreshAll(), 100);
    } catch (error) {
      console.error('âŒ ì–¸ì–´ ë³€ê²½ ì‹¤íŒ¨:', error);
      vscode.window.showErrorMessage(`ì–¸ì–´ ë³€ê²½ ì‹¤íŒ¨: ${error}`);
    }
  }

  private async _handleUpdateProgress(index: number, newProgress: number) {
    try {
      const vaultPath = this.vaultParser.getVaultPath();
      if (!vaultPath) {
        vscode.window.showErrorMessage('vault ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
      }

      const wipFilePath = path.join(vaultPath, 'projects', 'current-wip.md');
      const fs = await import('fs');
      const content = fs.readFileSync(wipFilePath, 'utf-8');
      const lines = content.split('\n');

      const regexWithTag = /^\d+\.\s+\[(.+?)\]\s+(.+?)\s+-\s+(\d+)%/;
      const regexWithoutTag = /^\d+\.\s+([^\[].+?)\s+-\s+(\d+)%/;
      let wipCount = 0;
      let targetLineIndex = -1;

      for (let i = 0; i < lines.length; i++) {
        const matchWithTag = lines[i].match(regexWithTag);
        const matchWithoutTag = lines[i].match(regexWithoutTag);

        if (matchWithTag || matchWithoutTag) {
          if (wipCount === index) {
            targetLineIndex = i;
            break;
          }
          wipCount++;
        }
      }

      if (targetLineIndex === -1) {
        vscode.window.showErrorMessage('WIP í•­ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
      }

      const line = lines[targetLineIndex];
      lines[targetLineIndex] = line.replace(/\d+%/, `${newProgress}%`);

      fs.writeFileSync(wipFilePath, lines.join('\n'), 'utf-8');
      console.log(`âœ… Progress ì—…ë°ì´íŠ¸: ${newProgress}%`);

      setTimeout(() => BaseViewProvider.refreshAll(), 100);
    } catch (error) {
      console.error('âŒ Progress ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', error);
      vscode.window.showErrorMessage(`Progress ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ${error}`);
    }
  }

  private async _handleCompleteWip(index: number) {
    try {
      const vaultPath = this.vaultParser.getVaultPath();
      if (!vaultPath) {
        vscode.window.showErrorMessage('vault ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
      }

      const wipFilePath = path.join(vaultPath, 'projects', 'current-wip.md');
      const fs = await import('fs');
      const content = fs.readFileSync(wipFilePath, 'utf-8');
      const lines = content.split('\n');

      const regexWithTag = /^\d+\.\s+\[(.+?)\]\s+(.+?)\s+-\s+(\d+)%/;
      const regexWithoutTag = /^\d+\.\s+([^\[].+?)\s+-\s+(\d+)%/;
      let wipCount = 0;
      let targetLineIndex = -1;
      let completedItem = '';

      for (let i = 0; i < lines.length; i++) {
        const matchWithTag = lines[i].match(regexWithTag);
        const matchWithoutTag = lines[i].match(regexWithoutTag);

        if (matchWithTag || matchWithoutTag) {
          if (wipCount === index) {
            targetLineIndex = i;
            completedItem = lines[i].replace(/\d+%/, '100%');
            break;
          }
          wipCount++;
        }
      }

      if (targetLineIndex === -1) {
        vscode.window.showErrorMessage('WIP í•­ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
      }

      // Remove from WIP section
      lines.splice(targetLineIndex, 1);

      // Find or create completed section
      let completedSectionIndex = lines.findIndex(line => line.startsWith('# ì™„ë£Œëœ ì‘ì—…'));

      if (completedSectionIndex === -1) {
        // Add completed section if it doesn't exist
        lines.push('', '# ì™„ë£Œëœ ì‘ì—…', completedItem);
      } else {
        // Add to completed section
        lines.splice(completedSectionIndex + 1, 0, completedItem);
      }

      // Renumber WIP items
      wipCount = 1;
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].match(regexWithTag)) {
          lines[i] = lines[i].replace(/^\d+\./, `${wipCount}.`);
          wipCount++;
        } else if (lines[i].match(regexWithoutTag)) {
          lines[i] = lines[i].replace(/^\d+\./, `${wipCount}.`);
          wipCount++;
        }
      }

      fs.writeFileSync(wipFilePath, lines.join('\n'), 'utf-8');
      vscode.window.showInformationMessage('âœ… ì‘ì—… ì™„ë£Œ!');

      setTimeout(() => BaseViewProvider.refreshAll(), 100);
    } catch (error) {
      console.error('âŒ ì™„ë£Œ ì²˜ë¦¬ ì‹¤íŒ¨:', error);
      vscode.window.showErrorMessage(`ì™„ë£Œ ì²˜ë¦¬ ì‹¤íŒ¨: ${error}`);
    }
  }

  private async _handleDeleteWip(index: number) {
    try {
      const vaultPath = this.vaultParser.getVaultPath();
      if (!vaultPath) {
        vscode.window.showErrorMessage('vault ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
      }

      const wipFilePath = path.join(vaultPath, 'projects', 'current-wip.md');
      const fs = await import('fs');
      const content = fs.readFileSync(wipFilePath, 'utf-8');
      const lines = content.split('\n');

      const regexWithTag = /^\d+\.\s+\[(.+?)\]\s+(.+?)\s+-\s+(\d+)%/;
      const regexWithoutTag = /^\d+\.\s+([^\[].+?)\s+-\s+(\d+)%/;
      let wipCount = 0;
      let targetLineIndex = -1;

      for (let i = 0; i < lines.length; i++) {
        const matchWithTag = lines[i].match(regexWithTag);
        const matchWithoutTag = lines[i].match(regexWithoutTag);

        if (matchWithTag || matchWithoutTag) {
          if (wipCount === index) {
            targetLineIndex = i;
            break;
          }
          wipCount++;
        }
      }

      if (targetLineIndex === -1) {
        vscode.window.showErrorMessage('WIP í•­ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
      }

      // Remove the item
      lines.splice(targetLineIndex, 1);

      // Renumber WIP items
      wipCount = 1;
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].match(regexWithTag)) {
          lines[i] = lines[i].replace(/^\d+\./, `${wipCount}.`);
          wipCount++;
        } else if (lines[i].match(regexWithoutTag)) {
          lines[i] = lines[i].replace(/^\d+\./, `${wipCount}.`);
          wipCount++;
        }
      }

      fs.writeFileSync(wipFilePath, lines.join('\n'), 'utf-8');
      console.log('âœ… WIP í•­ëª© ì‚­ì œ');

      setTimeout(() => BaseViewProvider.refreshAll(), 100);
    } catch (error) {
      console.error('âŒ ì‚­ì œ ì‹¤íŒ¨:', error);
      vscode.window.showErrorMessage(`ì‚­ì œ ì‹¤íŒ¨: ${error}`);
    }
  }

  protected async _update() {
    if (!this._view) {
      console.warn(`âš ï¸ ${this.viewType} Viewê°€ ì—†ì–´ì„œ ì—…ë°ì´íŠ¸ ë¶ˆê°€`);
      return;
    }

    try {
      console.log(`ğŸ“Š ${this.viewType} ë°ì´í„° íŒŒì‹± ì‹œì‘...`);
      const data = await this.vaultParser.parse();

      // ì„¤ì •ì—ì„œ ì–¸ì–´ ê°€ì ¸ì˜¤ê¸°
      const config = vscode.workspace.getConfiguration('productLife');
      const language = config.get<'ko' | 'en'>('language', 'ko');

      console.log(`âœ… ${this.viewType} íŒŒì‹± ì™„ë£Œ:`, {
        wip: data.wip.length,
        checklist: data.checklist.length,
        language
      });

      this._view.webview.postMessage({
        type: 'update',
        viewType: this.viewType,
        data: {
          ...data,
          language
        }
      });
      console.log(`ğŸ“¤ ${this.viewType} ë©”ì‹œì§€ ì „ì†¡ ì™„ë£Œ`);
    } catch (error) {
      console.error(`âŒ ${this.viewType} Update ì‹¤íŒ¨:`, error);
      vscode.window.showErrorMessage(`${this.viewType} ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ${error}`);
    }
  }

  private _getHtmlForWebview(webview: vscode.Webview): string {
    const scriptUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'out', 'webview.js')
    );
    const styleUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'out', 'webview.css')
    );

    return `<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src ${webview.cspSource};">
  <title>Product Life</title>
  <link rel="stylesheet" href="${styleUri}">
</head>
<body>
  <div id="root" data-view-type="${this.viewType}"></div>
  <script src="${scriptUri}"></script>
</body>
</html>`;
  }
}

// ê° ë·°ë¥¼ ìœ„í•œ Provider í´ë˜ìŠ¤ë“¤
export class QuickAddViewProvider extends BaseViewProvider {
  constructor(extensionUri: vscode.Uri) {
    super(extensionUri, 'quickAdd');
  }
}

export class WipViewProvider extends BaseViewProvider {
  constructor(extensionUri: vscode.Uri) {
    super(extensionUri, 'wip');
  }
}

export class ChecklistViewProvider extends BaseViewProvider {
  constructor(extensionUri: vscode.Uri) {
    super(extensionUri, 'checklist');
  }
}

export class TagManagerViewProvider extends BaseViewProvider {
  constructor(extensionUri: vscode.Uri) {
    super(extensionUri, 'tagManager');
  }
}

export class SettingsViewProvider extends BaseViewProvider {
  constructor(extensionUri: vscode.Uri) {
    super(extensionUri, 'settings');
  }
}
